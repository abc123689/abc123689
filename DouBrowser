DouBrowser | è±†æµè§ˆå™¨

ä¸€ä¸ªå®Œå…¨ç‹¬ç«‹ã€è‡ªä¸»å¼€å‘çš„æµè§ˆå™¨å¼•æ“å’Œæµè§ˆå™¨ï¼Œä¸åŸºäºAndroidç³»ç»Ÿï¼Œä¸ä½¿ç”¨Chromiumå†…æ ¸ï¼Œä¸ä¸ä»»ä½•å¤–éƒ¨æœåŠ¡ç»‘å®šã€‚åŸºäºè±†ç”Ÿæ€çš„å¾®å†…æ ¸æ¶æ„å’Œéšç§ä¼˜å…ˆç†å¿µã€‚

ğŸ¯ é¡¹ç›®ç›®æ ‡

Â· å®Œå…¨ç‹¬ç«‹è‡ªä¸»ï¼šä»é›¶å¼€å§‹å¼€å‘æµè§ˆå™¨å¼•æ“ï¼Œä¸ä¾èµ–Chromiumã€WebKitã€Geckoç­‰ç°æœ‰å¼•æ“
Â· å½»åº•å»è°·æ­ŒåŒ–ï¼šä¸ä½¿ç”¨ä»»ä½•GoogleæŠ€æœ¯æ ˆã€ä¸é›†æˆGoogleæœåŠ¡ã€ä¸ä¾èµ–Androidæ¡†æ¶
Â· éšç§è‡³ä¸Šï¼šè®¾è®¡ä¸Šé˜²æ­¢æ•°æ®æ³„éœ²ï¼Œæ‰€æœ‰å¤„ç†æœ¬åœ°åŒ–
Â· å®‰å…¨æ¶æ„ï¼šåŸºäºè±†ç”Ÿæ€èƒ½åŠ›æ¨¡å‹çš„è¿›ç¨‹çº§éš”ç¦»
Â· è½»é‡åŒ–ï¼šä¸“æ³¨äºæ ¸å¿ƒæµè§ˆåŠŸèƒ½ï¼Œé¿å…ä»£ç è†¨èƒ€

ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 è±†æµè§ˆå™¨ç”¨æˆ·ç•Œé¢                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚   â”‚   æ ‡ç­¾ç®¡ç†  â”‚   ä¹¦ç­¾ç®¡ç†  â”‚   è®¾ç½®ç•Œé¢  â”‚     â”‚
â”œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¤
â”‚                è±†æµè§ˆå™¨å¼•æ“å±‚                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚   è‡ªä¸»æ¸²æŸ“å¼•æ“                              â”‚ â”‚
â”‚   â”‚   â€¢ HTML/CSSè§£æå™¨                          â”‚ â”‚
â”‚   â”‚   â€¢ JavaScriptè™šæ‹Ÿæœº                        â”‚ â”‚
â”‚   â”‚   â€¢ 2Dæ¸²æŸ“ç®¡é“                              â”‚ â”‚
â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚   è‡ªä¸»ç½‘ç»œæ ˆ                               â”‚ â”‚
â”‚   â”‚   â€¢ HTTP/HTTPSå®¢æˆ·ç«¯                        â”‚ â”‚
â”‚   â”‚   â€¢ DNSè§£æå™¨                               â”‚ â”‚
â”‚   â”‚   â€¢ TLSå®ç°                                 â”‚ â”‚
â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚   è‡ªä¸»JavaScriptå¼•æ“                       â”‚ â”‚
â”‚   â”‚   â€¢ ECMAScriptå…¼å®¹                          â”‚ â”‚
â”‚   â”‚   â€¢ å†…å­˜å®‰å…¨ç®¡ç†                            â”‚ â”‚
â”‚   â”‚   â€¢ JITç¼–è¯‘å™¨                               â”‚ â”‚
â””â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
    â”‚   è±†ç”Ÿæ€é›†æˆå±‚                               â”‚ â”‚
    â”‚   â€¢ èƒ½åŠ›æ¨¡å‹æˆæƒ                            â”‚ â”‚
    â”‚   â€¢ å®‰å…¨æ²™ç®±                                â”‚ â”‚
    â”‚   â€¢ ç¦»çº¿AIæ¥å£                              â”‚ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                    DouKernel å¾®å†…æ ¸                â”‚
                    (èƒ½åŠ›æ§åˆ¶ã€è¿›ç¨‹éš”ç¦»)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

ğŸ”§ æŠ€æœ¯æ ˆé€‰æ‹©

å®Œå…¨è‡ªä¸»å¼€å‘ç»„ä»¶

ç»„ä»¶ æŠ€æœ¯é€‰æ‹© è®¾è®¡åŸåˆ™
HTMLè§£æå™¨ è‡ªç ”åŸºäºçŠ¶æ€æœºçš„è§£æå™¨ æ¸è¿›å¼è§£æã€å®¹é”™å¤„ç†
CSSå¼•æ“ è‡ªç ”é€‰æ‹©å™¨åŒ¹é…å’Œè®¡ç®— æ”¯æŒCSS3æ ¸å¿ƒç‰¹æ€§
JavaScriptå¼•æ“ è‡ªç ”å­—èŠ‚ç è§£é‡Šå™¨ + JIT å†…å­˜å®‰å…¨ã€æ— JITé€ƒé€¸
2Dæ¸²æŸ“ åŸºäºVulkançš„å‘é‡å›¾å½¢ GPUåŠ é€Ÿã€æ— é—ç•™API
ç½‘ç»œæ ˆ è‡ªç ”HTTP/2ã€TLS 1.3 æœ€å°æ”»å‡»é¢ã€å½¢å¼åŒ–éªŒè¯
å¤šåª’ä½“ ç®€åŒ–ç¼–è§£ç å™¨æ”¯æŒ ä»…æ”¯æŒå¼€æ”¾æ ¼å¼

å¼€å‘è¯­è¨€

Â· æ ¸å¿ƒå¼•æ“ï¼šRustï¼ˆå†…å­˜å®‰å…¨ã€æ€§èƒ½ï¼‰
Â· ç³»ç»Ÿæ¥å£ï¼šCï¼ˆå¾®å†…æ ¸å…¼å®¹ï¼‰
Â· ç”¨æˆ·ç•Œé¢ï¼šè±†ç”Ÿæ€UIæ¡†æ¶
Â· å·¥å…·é“¾ï¼šè‡ªç ”æ„å»ºç³»ç»Ÿ

ğŸ“ é¡¹ç›®ç»“æ„

```
DouBrowser/
â”œâ”€â”€ README.md                    # é¡¹ç›®è¯´æ˜
â”œâ”€â”€ LICENSE                      # å¼€æºåè®®(GPLv3)
â”œâ”€â”€ doubuild.toml               # è±†ç”Ÿæ€æ„å»ºé…ç½®
â”œâ”€â”€ docs/                       # æ–‡æ¡£
â”‚   â”œâ”€â”€ ARCHITECTURE.md         # æ¶æ„è®¾è®¡æ–‡æ¡£
â”‚   â”œâ”€â”€ SECURITY_DESIGN.md      # å®‰å…¨è®¾è®¡æ–‡æ¡£
â”‚   â”œâ”€â”€ PROTOCOL_SUPPORT.md     # åè®®æ”¯æŒæ–‡æ¡£
â”‚   â””â”€â”€ API_REFERENCE.md        # APIå‚è€ƒ
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ browser/               # æµè§ˆå™¨ä¸»è¿›ç¨‹
â”‚   â”‚   â”œâ”€â”€ main.rs           # å…¥å£ç‚¹
â”‚   â”‚   â”œâ”€â”€ window.rs         # çª—å£ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ tab.rs            # æ ‡ç­¾ç®¡ç†
â”‚   â”‚   â””â”€â”€ session.rs        # ä¼šè¯ç®¡ç†
â”‚   â”œâ”€â”€ render/               # æ¸²æŸ“å¼•æ“
â”‚   â”‚   â”œâ”€â”€ html/
â”‚   â”‚   â”‚   â”œâ”€â”€ parser.rs     # HTMLè§£æå™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ dom.rs        # DOMæ ‘å®ç°
â”‚   â”‚   â”‚   â””â”€â”€ tokenizer.rs  # è¯æ³•åˆ†æå™¨
â”‚   â”‚   â”œâ”€â”€ css/
â”‚   â”‚   â”‚   â”œâ”€â”€ parser.rs     # CSSè§£æå™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ selector.rs   # é€‰æ‹©å™¨å¼•æ“
â”‚   â”‚   â”‚   â””â”€â”€ cascade.rs    # æ ·å¼è®¡ç®—
â”‚   â”‚   â”œâ”€â”€ layout/           # å¸ƒå±€å¼•æ“
â”‚   â”‚   â”œâ”€â”€ paint/            # ç»˜åˆ¶å¼•æ“
â”‚   â”‚   â””â”€â”€ composite/        # åˆæˆå™¨
â”‚   â”œâ”€â”€ js/                   # JavaScriptå¼•æ“
â”‚   â”‚   â”œâ”€â”€ vm.rs            # è™šæ‹Ÿæœº
â”‚   â”‚   â”œâ”€â”€ parser.rs        # è¯­æ³•åˆ†æå™¨
â”‚   â”‚   â”œâ”€â”€ bytecode.rs      # å­—èŠ‚ç ç”Ÿæˆ
â”‚   â”‚   â”œâ”€â”€ jit/             # JITç¼–è¯‘å™¨
â”‚   â”‚   â””â”€â”€ builtins/        # å†…ç½®å¯¹è±¡
â”‚   â”œâ”€â”€ net/                  # ç½‘ç»œæ ˆ
â”‚   â”‚   â”œâ”€â”€ http/            # HTTPå®ç°
â”‚   â”‚   â”œâ”€â”€ tls/             # TLSå®ç°
â”‚   â”‚   â”œâ”€â”€ dns.rs           # DNSè§£æå™¨
â”‚   â”‚   â””â”€â”€ cache.rs         # æœ¬åœ°ç¼“å­˜
â”‚   â”œâ”€â”€ storage/             # æœ¬åœ°å­˜å‚¨
â”‚   â”‚   â”œâ”€â”€ local_storage.rs
â”‚   â”‚   â”œâ”€â”€ indexed_db.rs
â”‚   â”‚   â””â”€â”€ cookies.rs
â”‚   â””â”€â”€ integration/         # è±†ç”Ÿæ€é›†æˆ
â”‚       â”œâ”€â”€ capability.rs    # èƒ½åŠ›æ¨¡å‹
â”‚       â”œâ”€â”€ sandbox.rs       # æ²™ç®±éš”ç¦»
â”‚       â””â”€â”€ doujuice.rs      # è±†æ±åŠ©æ‰‹é›†æˆ
â”œâ”€â”€ resources/               # èµ„æºæ–‡ä»¶
â”‚   â”œâ”€â”€ default.css         # é»˜è®¤æ ·å¼
â”‚   â”œâ”€â”€ user_agent.css      # ç”¨æˆ·ä»£ç†æ ·å¼
â”‚   â””â”€â”€ icons/              # å›¾æ ‡èµ„æº
â”œâ”€â”€ tests/                  # æµ‹è¯•å¥—ä»¶
â”‚   â”œâ”€â”€ html/               # HTMLè§£ææµ‹è¯•
â”‚   â”œâ”€â”€ css/                # CSSè§£ææµ‹è¯•
â”‚   â”œâ”€â”€ js/                 # JSå¼•æ“æµ‹è¯•
â”‚   â””â”€â”€ integration/        # é›†æˆæµ‹è¯•
â””â”€â”€ tools/                  # å¼€å‘å·¥å…·
    â”œâ”€â”€ test_server/        # æµ‹è¯•HTTPæœåŠ¡å™¨
    â””â”€â”€ debugger/           # è°ƒè¯•å·¥å…·
```

ğŸš€ æ ¸å¿ƒä»£ç ç¤ºä¾‹

1. è‡ªä¸»HTMLè§£æå™¨

```rust
// æ–‡ä»¶ï¼šsrc/render/html/parser.rs
// å®Œå…¨è‡ªä¸»å¼€å‘çš„HTML5è§£æå™¨

pub struct HTMLParser {
    tokenizer: HTMLTokenizer,
    tree_builder: DOMTreeBuilder,
    parsing_mode: ParsingMode,
}

impl HTMLParser {
    pub fn new() -> Self {
        HTMLParser {
            tokenizer: HTMLTokenizer::new(),
            tree_builder: DOMTreeBuilder::new(),
            parsing_mode: ParsingMode::NoQuirks,
        }
    }
    
    pub fn parse(&mut self, input: &str, url: &Url) -> Result<Rc<Document>, ParseError> {
        // åˆ›å»ºæ–‡æ¡£å¯¹è±¡
        let document = Document::new(url.clone());
        
        // åˆå§‹åŒ–æ ‘æ„å»ºå™¨
        self.tree_builder.set_document(document.clone());
        
        // åˆ†è¯å’Œè§£æ
        let mut chars = input.chars().peekable();
        while let Some(token) = self.tokenizer.next_token(&mut chars) {
            match token {
                Token::StartTag { name, attributes, self_closing } => {
                    self.tree_builder.insert_element(name, attributes, self_closing);
                }
                Token::EndTag(name) => {
                    self.tree_builder.close_element(name);
                }
                Token::Character(data) => {
                    self.tree_builder.insert_text(data);
                }
                Token::Comment(data) => {
                    self.tree_builder.insert_comment(data);
                }
                Token::Doctype { name, public_id, system_id } => {
                    self.tree_builder.insert_doctype(name, public_id, system_id);
                }
                Token::EOF => break,
            }
        }
        
        // å®Œæˆæ–‡æ¡£æ„å»º
        self.tree_builder.finish();
        Ok(document)
    }
}

// HTMLåˆ†è¯å™¨ï¼ˆè¯æ³•åˆ†æï¼‰
struct HTMLTokenizer {
    state: TokenizerState,
    last_start_tag: Option<String>,
}

impl HTMLTokenizer {
    fn next_token<I>(&mut self, input: &mut Peekable<I>) -> Option<Token>
    where
        I: Iterator<Item = char>,
    {
        match self.state {
            TokenizerState::Data => self.data_state(input),
            TokenizerState::TagOpen => self.tag_open_state(input),
            TokenizerState::EndTagOpen => self.end_tag_open_state(input),
            TokenizerState::TagName => self.tag_name_state(input),
            // ... å…¶ä»–çŠ¶æ€å¤„ç†
            _ => None,
        }
    }
    
    fn data_state<I>(&mut self, input: &mut Peekable<I>) -> Option<Token>
    where
        I: Iterator<Item = char>,
    {
        match input.peek() {
            Some('<') => {
                input.next(); // æ¶ˆè€— '<'
                self.state = TokenizerState::TagOpen;
                None
            }
            Some('&') => {
                // å¤„ç†å­—ç¬¦å®ä½“
                self.character_reference_state(input)
            }
            Some(_) => {
                // æ”¶é›†æ–‡æœ¬å­—ç¬¦
                let mut text = String::new();
                while let Some(&ch) = input.peek() {
                    if ch == '<' || ch == '&' {
                        break;
                    }
                    text.push(ch);
                    input.next();
                }
                Some(Token::Character(text))
            }
            None => Some(Token::EOF),
        }
    }
}
```

2. è‡ªä¸»CSSå¼•æ“

```rust
// æ–‡ä»¶ï¼šsrc/render/css/selector.rs
// CSSé€‰æ‹©å™¨åŒ¹é…å¼•æ“

pub struct SelectorMatcher {
    selectors: Vec<Selector>,
}

impl SelectorMatcher {
    pub fn new(css_text: &str) -> Result<Self, ParseError> {
        let parser = CSSParser::new(css_text);
        let selectors = parser.parse_selectors()?;
        Ok(SelectorMatcher { selectors })
    }
    
    pub fn match_element(&self, element: &Element) -> Vec<MatchedRule> {
        let mut matched_rules = Vec::new();
        
        for selector in &self.selectors {
            if self.selector_matches(selector, element) {
                matched_rules.push(MatchedRule {
                    selector: selector.clone(),
                    specificity: selector.specificity(),
                });
            }
        }
        
        // æŒ‰ç‰¹å¼‚æ€§æ’åº
        matched_rules.sort_by_key(|rule| rule.specificity);
        matched_rules
    }
    
    fn selector_matches(&self, selector: &Selector, element: &Element) -> bool {
        // æ£€æŸ¥æ¯ä¸ªç®€å•é€‰æ‹©å™¨
        for simple_selector in &selector.simple_selectors {
            match simple_selector {
                SimpleSelector::Universal => continue, // * åŒ¹é…æ‰€æœ‰
                SimpleSelector::Type(tag_name) => {
                    if element.tag_name() != *tag_name {
                        return false;
                    }
                }
                SimpleSelector::Class(class) => {
                    if !element.has_class(class) {
                        return false;
                    }
                }
                SimpleSelector::Id(id) => {
                    if element.id() != Some(id) {
                        return false;
                    }
                }
                SimpleSelector::Attribute { name, operator, value } => {
                    if !self.attribute_matches(element, name, operator, value) {
                        return false;
                    }
                }
                SimpleSelector::PseudoClass(pseudo) => {
                    if !self.pseudo_class_matches(element, pseudo) {
                        return false;
                    }
                }
            }
        }
        
        true
    }
}

// CSSæ ·å¼è®¡ç®—
pub struct StyleComputer {
    user_agent_styles: StyleSheet,
    author_styles: Vec<StyleSheet>,
    cascade: Cascade,
}

impl StyleComputer {
    pub fn compute_style(&self, element: &Element) -> ComputedStyle {
        let mut declarations = Vec::new();
        
        // 1. æ”¶é›†ç”¨æˆ·ä»£ç†æ ·å¼
        declarations.extend(self.user_agent_styles.matching_rules(element));
        
        // 2. æ”¶é›†ä½œè€…æ ·å¼
        for sheet in &self.author_styles {
            declarations.extend(sheet.matching_rules(element));
        }
        
        // 3. æ”¶é›†å†…è”æ ·å¼
        if let Some(inline_style) = element.inline_style() {
            declarations.push((inline_style.clone(), Specificity::new(1, 0, 0, 0)));
        }
        
        // 4. å±‚å è®¡ç®—
        self.cascade.compute(declarations)
    }
}
```

3. è‡ªä¸»JavaScriptå¼•æ“

```rust
// æ–‡ä»¶ï¼šsrc/js/vm.rs
// è‡ªä¸»JavaScriptè™šæ‹Ÿæœº

pub struct JavaScriptVM {
    heap: Heap,
    call_stack: CallStack,
    global_object: Object,
    bytecode_interpreter: BytecodeInterpreter,
}

impl JavaScriptVM {
    pub fn new() -> Self {
        let mut vm = JavaScriptVM {
            heap: Heap::new(),
            call_stack: CallStack::with_capacity(1024),
            global_object: Object::new(),
            bytecode_interpreter: BytecodeInterpreter::new(),
        };
        
        // åˆå§‹åŒ–å†…ç½®å¯¹è±¡
        vm.init_global_object();
        vm
    }
    
    fn init_global_object(&mut self) {
        // å®šä¹‰å…¨å±€å¯¹è±¡å±æ€§
        self.global_object.define_property(
            "undefined",
            Property::new(Value::Undefined, false, false, false)
        );
        
        self.global_object.define_property(
            "Infinity",
            Property::new(Value::Number(f64::INFINITY), false, false, false)
        );
        
        // å®šä¹‰å…¨å±€å‡½æ•°
        self.global_object.define_function("parseInt", Self::global_parse_int);
        self.global_object.define_function("parseFloat", Self::global_parse_float);
        self.global_object.define_function("isNaN", Self::global_is_nan);
        
        // å®šä¹‰å†…ç½®å¯¹è±¡æ„é€ å‡½æ•°
        self.global_object.define_property(
            "Object",
            Property::new(Value::Object(ObjectConstructor::new()), true, false, true)
        );
        
        self.global_object.define_property(
            "Array",
            Property::new(Value::Object(ArrayConstructor::new()), true, false, true)
        );
        
        // æ›´å¤šå†…ç½®å¯¹è±¡...
    }
    
    pub fn execute(&mut self, bytecode: &Bytecode) -> Result<Value, RuntimeError> {
        // è®¾ç½®æ‰§è¡Œç¯å¢ƒ
        let env = ExecutionEnvironment::new(&self.global_object);
        self.call_stack.push_frame(Frame::new(bytecode, env));
        
        // è§£é‡Šæ‰§è¡Œå­—èŠ‚ç 
        while let Some(frame) = self.call_stack.current_frame() {
            let result = self.bytecode_interpreter.execute_frame(
                frame,
                &mut self.heap,
                &mut self.call_stack
            );
            
            match result {
                InterpretResult::Return(value) => {
                    self.call_stack.pop_frame();
                    if self.call_stack.is_empty() {
                        return Ok(value);
                    } else {
                        // å°†è¿”å›å€¼ä¼ é€’ç»™è°ƒç”¨è€…
                        self.call_stack.current_frame_mut().unwrap().push_value(value);
                    }
                }
                InterpretResult::Yield => {
                    // æš‚åœæ‰§è¡Œï¼ˆç”¨äºå¼‚æ­¥æ“ä½œï¼‰
                    break;
                }
                InterpretResult::Error(err) => {
                    return Err(err);
                }
                InterpretResult::Continue => {
                    // ç»§ç»­æ‰§è¡Œä¸‹ä¸€æŒ‡ä»¤
                }
            }
        }
        
        Ok(Value::Undefined)
    }
}

// å­—èŠ‚ç æŒ‡ä»¤é›†
#[derive(Debug, Clone, Copy)]
pub enum Bytecode {
    LoadConst(usize),     // åŠ è½½å¸¸é‡
    LoadLocal(usize),     // åŠ è½½å±€éƒ¨å˜é‡
    StoreLocal(usize),    // å­˜å‚¨åˆ°å±€éƒ¨å˜é‡
    LoadGlobal(String),   // åŠ è½½å…¨å±€å˜é‡
    StoreGlobal(String),  // å­˜å‚¨åˆ°å…¨å±€å˜é‡
    Add,                  // åŠ æ³•
    Sub,                  // å‡æ³•
    Mul,                  // ä¹˜æ³•
    Div,                  // é™¤æ³•
    Call(usize),          // å‡½æ•°è°ƒç”¨ï¼ˆå‚æ•°ä¸ªæ•°ï¼‰
    Return,               // è¿”å›å€¼
    Jump(usize),          // æ— æ¡ä»¶è·³è½¬
    JumpIfFalse(usize),   // æ¡ä»¶è·³è½¬ï¼ˆå‡ï¼‰
    // ... æ›´å¤šæŒ‡ä»¤
}
```

4. è±†ç”Ÿæ€èƒ½åŠ›æ¨¡å‹é›†æˆ

```rust
// æ–‡ä»¶ï¼šsrc/integration/capability.rs
// æµè§ˆå™¨ä¸è±†ç”Ÿæ€èƒ½åŠ›æ¨¡å‹çš„å®‰å…¨é›†æˆ

pub struct CapabilityManager {
    kernel_endpoint: KernelEndpoint,
    browser_caps: BrowserCapabilities,
    sandbox_manager: SandboxManager,
}

impl CapabilityManager {
    pub fn new() -> Result<Self, CapabilityError> {
        // è¿æ¥åˆ°è±†å¾®å†…æ ¸
        let endpoint = KernelEndpoint::connect()?;
        
        // è¯·æ±‚æµè§ˆå™¨åŸºç¡€èƒ½åŠ›
        let base_caps = endpoint.request_capabilities(&[
            CapabilityRequest::new("network-access", CapabilityScope::Global),
            CapabilityRequest::new("local-storage", CapabilityScope::Process),
            CapabilityRequest::new("ui-display", CapabilityScope::Process),
        ])?;
        
        Ok(CapabilityManager {
            kernel_endpoint: endpoint,
            browser_caps: BrowserCapabilities::new(base_caps),
            sandbox_manager: SandboxManager::new(),
        })
    }
    
    // ä¸ºæ ‡ç­¾é¡µåˆ›å»ºå®‰å…¨æ²™ç®±
    pub fn create_tab_sandbox(&self, url: &Url) -> Result<TabSandbox, SandboxError> {
        // åˆ†æURLç¡®å®šæ‰€éœ€èƒ½åŠ›
        let required_caps = self.analyze_url_capabilities(url);
        
        // å‘å†…æ ¸è¯·æ±‚åˆ›å»ºæ–°çš„ä¿æŠ¤åŸŸ
        let protection_domain = self.kernel_endpoint.create_protection_domain(
            &format!("tab-{}", url.host_str().unwrap_or("unknown"))
        )?;
        
        // æˆäºˆæœ€å°å¿…è¦èƒ½åŠ›
        for cap_request in &required_caps {
            let capability = self.kernel_endpoint.derive_capability(
                &self.browser_caps,
                cap_request,
                &protection_domain
            )?;
            
            protection_domain.grant_capability(capability)?;
        }
        
        // åˆ›å»ºæ²™ç®±ç¯å¢ƒ
        let sandbox = self.sandbox_manager.create_sandbox(
            protection_domain,
            required_caps
        )?;
        
        Ok(sandbox)
    }
    
    fn analyze_url_capabilities(&self, url: &Url) -> Vec<CapabilityRequest> {
        let mut caps = vec![
            CapabilityRequest::new("dom-access", CapabilityScope::Domain(url.domain())),
            CapabilityRequest::new("script-execution", CapabilityScope::Domain(url.domain())),
        ];
        
        // æ ¹æ®URLåè®®æ·»åŠ é¢å¤–èƒ½åŠ›
        match url.scheme() {
            "http" | "https" => {
                caps.push(CapabilityRequest::new("network-fetch", CapabilityScope::Domain(url.domain())));
                caps.push(CapabilityRequest::new("cookie-access", CapabilityScope::Domain(url.domain())));
            }
            "file" => {
                caps.push(CapabilityRequest::new("file-access", CapabilityScope::Local));
            }
            _ => {
                // å…¶ä»–åè®®é»˜è®¤æ— ç½‘ç»œè®¿é—®
            }
        }
        
        caps
    }
}
```

5. éšç§ä¼˜å…ˆçš„ç½‘ç»œæ ˆ

```rust
// æ–‡ä»¶ï¼šsrc/net/http/client.rs
// è‡ªä¸»å¼€å‘çš„HTTPå®¢æˆ·ç«¯

pub struct HttpClient {
    connection_pool: ConnectionPool,
    dns_resolver: DnsResolver,
    cookie_jar: IsolatedCookieJar,
    ad_blocker: AdBlocker,
    tracker_blocker: TrackerBlocker,
}

impl HttpClient {
    pub async fn fetch(&self, request: HttpRequest) -> Result<HttpResponse, HttpError> {
        // 1. åº”ç”¨éšç§è§„åˆ™
        let filtered_request = self.apply_privacy_rules(request);
        
        // 2. DNSè§£æï¼ˆéšç§æ¨¡å¼ï¼‰
        let resolved = self.dns_resolver.resolve_privacy(
            &filtered_request.url.host_str().unwrap(),
            DnsOptions {
                use_doh: true,
                prevent_leakage: true,
            }
        ).await?;
        
        // 3. å»ºç«‹TLSè¿æ¥
        let mut connection = self.connection_pool.get_connection(
            &resolved,
            filtered_request.url.port_or_known_default().unwrap_or(443)
        ).await?;
        
        // 4. å‘é€è¯·æ±‚
        connection.send_request(filtered_request).await?;
        
        // 5. è¯»å–å“åº”
        let mut response = connection.read_response().await?;
        
        // 6. åº”ç”¨å†…å®¹è¿‡æ»¤å™¨
        response = self.filter_response(response).await?;
        
        // 7. éš”ç¦»å­˜å‚¨Cookie
        if let Some(cookies) = response.headers.get("set-cookie") {
            self.cookie_jar.store_isolated(
                &filtered_request.url,
                cookies,
                CookieIsolation::PerDomain
            );
        }
        
        Ok(response)
    }
    
    fn apply_privacy_rules(&self, mut request: HttpRequest) -> HttpRequest {
        // ç§»é™¤è¿½è¸ªå¤´
        request.headers.remove("user-agent");
        request.headers.remove("referer");
        request.headers.remove("cookie");
        
        // æ·»åŠ éšç§å‹å¥½çš„æ›¿ä»£å¤´
        request.headers.insert(
            "user-agent",
            "DouBrowser/1.0 (Privacy-focused)"
        );
        
        // å¯ç”¨éšç§ä¿æŠ¤
        request.headers.insert(
            "dnt",
            "1" // Do Not Track
        );
        
        request
    }
    
    async fn filter_response(&self, mut response: HttpResponse) -> Result<HttpResponse, HttpError> {
        // å¹¿å‘Šæ‹¦æˆª
        if self.ad_blocker.should_block(&response.url, &response.headers) {
            return Err(HttpError::Blocked("å¹¿å‘Šè¢«æ‹¦æˆª".to_string()));
        }
        
        // è¿½è¸ªå™¨æ‹¦æˆª
        if self.tracker_blocker.is_tracker(&response.url) {
            return Err(HttpError::Blocked("è¿½è¸ªå™¨è¢«æ‹¦æˆª".to_string()));
        }
        
        // å†…å®¹è¿‡æ»¤
        if let Some(content_type) = response.headers.get("content-type") {
            if content_type.contains("text/html") || content_type.contains("text/css") {
                response.body = self.filter_content(response.body).await;
            }
        }
        
        Ok(response)
    }
}
```

ğŸ“ˆ å¼€å‘è·¯çº¿å›¾

é˜¶æ®µ0ï¼šæ ¸å¿ƒå¼•æ“åŸºç¡€ (6-12ä¸ªæœˆ)

Â· HTML5è§£æå™¨åŸºç¡€å®ç°
Â· CSS3æ ¸å¿ƒé€‰æ‹©å™¨å’Œè®¡ç®—
Â· JavaScriptè§£é‡Šå™¨åŸºç¡€
Â· åŸºç¡€2Dæ¸²æŸ“ç®¡é“
Â· HTTP/1.1å®¢æˆ·ç«¯å®ç°

é˜¶æ®µ1ï¼šåŸºç¡€æµè§ˆå™¨åŠŸèƒ½ (12-18ä¸ªæœˆ)

Â· DOMæ ‘å®ç°å’Œæ“ä½œAPI
Â· åŸºæœ¬é¡µé¢å¸ƒå±€å’Œæ¸²æŸ“
Â· JavaScriptå¼•æ“åŸºç¡€åŠŸèƒ½
Â· æ ‡ç­¾é¡µç®¡ç†å’Œå¯¼èˆª
Â· ä¹¦ç­¾å’ŒåŸºç¡€å†å²è®°å½•

é˜¶æ®µ2ï¼šå®Œæ•´åŠŸèƒ½å®ç° (18-30ä¸ªæœˆ)

Â· CSS Grid/Flexboxæ”¯æŒ
Â· JavaScript JITç¼–è¯‘å™¨
Â· HTTP/2å’ŒTLS 1.3æ”¯æŒ
Â· Canvas 2D API
Â· å¼€å‘è€…å·¥å…·åŸºç¡€æ¡†æ¶

é˜¶æ®µ3ï¼šä¼˜åŒ–å’Œå®‰å…¨å¢å¼º (30-48ä¸ªæœˆ)

Â· WebAssemblyæ”¯æŒ
Â· å¤šè¿›ç¨‹æ¶æ„
Â· é«˜çº§å®‰å…¨æ²™ç®±
Â· æ€§èƒ½åˆ†æå’Œä¼˜åŒ–
Â· æ ‡å‡†å…¼å®¹æ€§æµ‹è¯•

ğŸ”¨ æ„å»ºæŒ‡å—

ç¯å¢ƒè¦æ±‚

Â· æ“ä½œç³»ç»Ÿï¼šè±†ç”Ÿæ€å¼€å‘ç¯å¢ƒæˆ–Linux
Â· å†…å­˜ï¼š8GB+ï¼ˆå»ºè®®16GBï¼‰
Â· å­˜å‚¨ï¼š50GB+ å¯ç”¨ç©ºé—´
Â· Rustå·¥å…·é“¾ï¼š1.70+ç‰ˆæœ¬
Â· è±†ç”Ÿæ€SDKï¼šæœ€æ–°ç‰ˆæœ¬

æ„å»ºæ­¥éª¤

```bash
# 1. è·å–æºä»£ç 
git clone https://github.com/DouEcoSys/DouBrowser.git
cd DouBrowser

# 2. å®‰è£…è±†ç”Ÿæ€å¼€å‘ç¯å¢ƒ
curl -fsSL https://douos.dev/setup.sh | bash

# 3. é…ç½®æ„å»º
doubuild configure --profile=release

# 4. ç¼–è¯‘æ ¸å¿ƒå¼•æ“
doubuild build engine

# 5. ç¼–è¯‘æµè§ˆå™¨ç•Œé¢
doubuild build browser

# 6. è¿è¡Œæµ‹è¯•
doubuild test --all

# 7. å¯åŠ¨æµè§ˆå™¨
./target/release/doubrowser --test-mode
```

ğŸ‘¥ è´¡çŒ®æŒ‡å—

éœ€è¦çš„æŠ€èƒ½

Â· Rustè¯­è¨€é«˜çº§ç‰¹æ€§
Â· æµè§ˆå™¨å¼•æ“å¼€å‘ç»éªŒ
Â· ç¼–è¯‘å™¨å’Œè§£é‡Šå™¨è®¾è®¡
Â· ç½‘ç»œåè®®å’Œå®‰å…¨
Â· å›¾å½¢æ¸²æŸ“å’ŒGPUç¼–ç¨‹

ä»£ç æ ‡å‡†

1. å®‰å…¨æ€§ä¼˜å…ˆï¼šæ‰€æœ‰ä»£ç å¿…é¡»é€šè¿‡å®‰å…¨æ£€æŸ¥
2. é›¶å¤–éƒ¨ä¾èµ–ï¼šç¦æ­¢å¼•å…¥ç¬¬ä¸‰æ–¹C/C++åº“
3. å†…å­˜å®‰å…¨ï¼šä½¿ç”¨Rustçš„å®‰å…¨ç‰¹æ€§
4. æœ€å°æƒé™ï¼šéµå¾ªè±†ç”Ÿæ€èƒ½åŠ›æ¨¡å‹
5. æ–‡æ¡£å®Œå¤‡ï¼šæ‰€æœ‰å…¬å…±APIå¿…é¡»æœ‰æ–‡æ¡£

è´¡çŒ®æµç¨‹

1. é˜…è¯»æ¶æ„æ–‡æ¡£å’Œè®¾è®¡åŸåˆ™
2. é€‰æ‹©"è‰¯å¥½å¼€ç«¯"æ ‡ç­¾çš„ä»»åŠ¡å¼€å§‹
3. ç¡®ä¿ä»£ç é€šè¿‡æ‰€æœ‰å®‰å…¨å’Œéšç§æ£€æŸ¥
4. æäº¤Pull Requestï¼Œé€šè¿‡CIæµ‹è¯•
5. æ¥å—æ ¸å¿ƒç»´æŠ¤è€…çš„ä»£ç å®¡æŸ¥

ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨ GNU General Public License v3.0ï¼Œç¡®ä¿æ‰€æœ‰è¡ç”Ÿä½œå“ä¿æŒå¼€æºå’Œè‡ªç”±ã€‚

ğŸ›¡ï¸ å®‰å…¨ä¸éšç§æ‰¿è¯º

1. å®Œå…¨è‡ªä¸»ï¼šä¸åŒ…å«ä»»ä½•ç¬¬ä¸‰æ–¹ä¸“æœ‰ä»£ç 
2. é›¶é¥æµ‹ï¼šä¸æ”¶é›†ä»»ä½•ä½¿ç”¨æ•°æ®æˆ–è¯Šæ–­ä¿¡æ¯
3. æœ¬åœ°å¤„ç†ï¼šæ‰€æœ‰æ•°æ®åœ¨è®¾å¤‡ç«¯å¤„ç†
4. é€æ˜å¯ä¿¡ï¼šä»èŠ¯ç‰‡åˆ°åº”ç”¨å®Œå…¨å¯å®¡è®¡
5. å®‰å…¨æ¶æ„ï¼šåŸºäºå½¢å¼åŒ–éªŒè¯çš„å¾®å†…æ ¸

---

è±†æµè§ˆå™¨ - ä»å†…æ ¸åˆ°ç•Œé¢çš„å®Œå…¨è‡ªä¸»ã€éšç§ä¼˜å…ˆçš„ç½‘é¡µæµè§ˆä½“éªŒ
