DouChat | è±†åŠ å¯†èŠå¤©

ä¸€ä¸ªå®Œå…¨ç«¯åˆ°ç«¯åŠ å¯†ã€è‡ªä¸»å¼€å‘ã€æ— å¤–éƒ¨ä¾èµ–çš„å³æ—¶é€šè®¯ç³»ç»Ÿï¼ŒåŒ…å«åŸç”Ÿåº”ç”¨å’ŒWebç‰ˆæœ¬ã€‚ä¸åŸºäºAndroidï¼Œä¸ä½¿ç”¨GoogleæŠ€æœ¯æ ˆï¼Œæ‰€æœ‰ç»„ä»¶å®Œå…¨è‡ªä¸»å®ç°ã€‚

ğŸ¯ é¡¹ç›®ç›®æ ‡

Â· å®Œå…¨ç«¯åˆ°ç«¯åŠ å¯†ï¼šè‡ªä¸»å®ç°Signalåè®®å˜ä½“ï¼Œå‰å‘ä¿å¯†ã€åå‘ä¿å¯†
Â· è·¨å¹³å°å…¼å®¹ï¼šåŸç”Ÿåº”ç”¨ï¼ˆè±†ç”Ÿæ€ï¼‰ + çº¯å‰ç«¯Webåº”ç”¨
Â· å»ä¸­å¿ƒåŒ–æ¶æ„ï¼šæ”¯æŒç‚¹å¯¹ç‚¹ç›´è¿å’Œä¸­ç»§æœåŠ¡å™¨æ··åˆæ¨¡å¼
Â· æ— å¤–éƒ¨ä¾èµ–ï¼šä¸ä½¿ç”¨ä»»ä½•ç¬¬ä¸‰æ–¹SDKæˆ–æœåŠ¡
Â· éšç§ä¼˜å…ˆï¼šå…ƒæ•°æ®æœ€å°åŒ–ã€æ— ç”¨æˆ·è¿½è¸ªã€æœ¬åœ°å¯†é’¥å­˜å‚¨

ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   è±†èŠå¤©åº”ç”¨å±‚                                â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚   â”‚   åŸç”Ÿåº”ç”¨     â”‚   Webåº”ç”¨     â”‚   CLIå·¥å…·     â”‚       â”‚
â”‚   â”‚  (è±†ç”Ÿæ€)      â”‚  (çº¯å‰ç«¯)      â”‚  (ç»ˆç«¯)        â”‚       â”‚
â”œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     ç»Ÿä¸€åè®®å±‚                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚   è±†èŠå¤©åè®® (DCP)                                   â”‚ â”‚
â”‚   â”‚   â€¢ æ¶ˆæ¯æ ¼å¼                                        â”‚ â”‚
â”‚   â”‚   â€¢ ä¼šè¯ç®¡ç†                                        â”‚ â”‚
â”‚   â”‚   â€¢ ç¾¤ç»„åè®®                                        â”‚ â”‚
â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚   ç«¯åˆ°ç«¯åŠ å¯†å±‚                                      â”‚ â”‚
â”‚   â”‚   â€¢ åŒæ£˜è½®ç®—æ³•                                      â”‚ â”‚
â”‚   â”‚   â€¢ X3DHå¯†é’¥äº¤æ¢                                    â”‚ â”‚
â”‚   â”‚   â€¢ åé‡å­åŠ å¯†                                      â”‚ â”‚
â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚   â”‚   ç½‘ç»œä¼ è¾“å±‚                                        â”‚ â”‚
â”‚   â”‚   â€¢ WebRTC (P2P)                                   â”‚ â”‚
â”‚   â”‚   â€¢ WebSocket (ä¸­ç»§)                                â”‚ â”‚
â”‚   â”‚   â€¢ Toræ”¯æŒ (å¯é€‰)                                  â”‚ â”‚
â””â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
    â”‚   è±†ç”Ÿæ€å®‰å…¨å±‚                                      â”‚ â”‚
    â”‚   â€¢ èƒ½åŠ›æ¨¡å‹éš”ç¦»                                    â”‚ â”‚
    â”‚   â€¢ å®‰å…¨å¯†é’¥å­˜å‚¨                                    â”‚ â”‚
    â”‚   â€¢ ç¡¬ä»¶å¯†é’¥æ”¯æŒ                                    â”‚ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                        DouKernel å¾®å†…æ ¸                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

ğŸ”§ æ ¸å¿ƒæŠ€æœ¯æ ˆ

å®Œå…¨è‡ªä¸»å®ç°ç»„ä»¶

ç»„ä»¶ æŠ€æœ¯å®ç° ç‰¹æ€§
ç«¯åˆ°ç«¯åŠ å¯†åè®® è‡ªä¸»Signalåè®®å˜ä½“ å‰å‘ä¿å¯†ã€åå‘ä¿å¯†ã€æ‹’ç»æœåŠ¡é˜²æŠ¤
å¯†é’¥ç®¡ç† åˆ†å±‚ç¡®å®šæ€§é’±åŒ… åŠ©è®°è¯æ¢å¤ã€å¤šè®¾å¤‡åŒæ­¥
ç½‘ç»œä¼ è¾“ è‡ªä¸»WebRTCæ ˆ + WebSocket NATç©¿é€ã€é™çº§å›é€€
æ¶ˆæ¯å­˜å‚¨ æœ¬åœ°åŠ å¯†æ•°æ®åº“ å®¢æˆ·ç«¯æœç´¢ã€é›¶çŸ¥è¯†è¯æ˜
èº«ä»½ç³»ç»Ÿ è‡ªä¸»åˆ†å¸ƒå¼èº«ä»½ éå¯¹ç§°å¯†é’¥å¯¹ã€å»ä¸­å¿ƒåŒ–è®¤è¯

åè®®è®¾è®¡åŸåˆ™

1. åè®®é€æ˜ï¼šæ‰€æœ‰åè®®è§„èŒƒå…¬å¼€å¯å®¡è®¡
2. å¯†ç å­¦æ•æ·ï¼šæ”¯æŒç®—æ³•æ— ç¼å‡çº§
3. å…ƒæ•°æ®ä¿æŠ¤ï¼šæœ€å°åŒ–æš´éœ²ä¿¡æ¯
4. å¯å¦è®¤æ€§ï¼šæ”¯æŒå¯å¦è®¤è®¤è¯
5. åé‡å­å®‰å…¨ï¼šæ”¯æŒæŠ—é‡å­æ”»å‡»ç®—æ³•

ğŸ“ é¡¹ç›®ç»“æ„

ä¸»ä»“åº“ï¼šDouChat

```
DouChat/
â”œâ”€â”€ README.md                    # é¡¹ç›®æ€»è§ˆ
â”œâ”€â”€ PROTOCOL.md                  # åè®®è§„èŒƒæ–‡æ¡£
â”œâ”€â”€ SECURITY.md                  # å®‰å…¨è®¾è®¡æ–‡æ¡£
â”œâ”€â”€ architecture/               # æ¶æ„è®¾è®¡æ–‡æ¡£
â”‚   â”œâ”€â”€ crypto-design.md        # å¯†ç å­¦è®¾è®¡
â”‚   â”œâ”€â”€ protocol-spec.md        # åè®®è¯¦ç»†è§„èŒƒ
â”‚   â””â”€â”€ threat-model.md         # å¨èƒæ¨¡å‹åˆ†æ
â”œâ”€â”€ core/                       # æ ¸å¿ƒåè®®åº“ (Rust)
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â”œâ”€â”€ crypto/            # å¯†ç å­¦å®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ double_ratchet.rs  # åŒæ£˜è½®ç®—æ³•
â”‚   â”‚   â”‚   â”œâ”€â”€ x3dh.rs            # X3DHå¯†é’¥äº¤æ¢
â”‚   â”‚   â”‚   â”œâ”€â”€ pqc.rs             # åé‡å­åŠ å¯†
â”‚   â”‚   â”‚   â””â”€â”€ signatures.rs      # æ•°å­—ç­¾å
â”‚   â”‚   â”œâ”€â”€ protocol/          # åè®®å®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ messages.rs        # æ¶ˆæ¯æ ¼å¼
â”‚   â”‚   â”‚   â”œâ”€â”€ sessions.rs        # ä¼šè¯ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ groups.rs          # ç¾¤ç»„åè®®
â”‚   â”‚   â”‚   â””â”€â”€ transport.rs       # ä¼ è¾“åè®®
â”‚   â”‚   â”œâ”€â”€ network/           # ç½‘ç»œå±‚
â”‚   â”‚   â”‚   â”œâ”€â”€ webrtc.rs          # WebRTCå®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ websocket.rs       # WebSocketå®ç°
â”‚   â”‚   â”‚   â””â”€â”€ nat.rs             # NATç©¿é€
â”‚   â”‚   â””â”€â”€ storage/           # å­˜å‚¨
â”‚   â”‚       â”œâ”€â”€ encrypted_db.rs    # åŠ å¯†æ•°æ®åº“
â”‚   â”‚       â”œâ”€â”€ key_store.rs       # å¯†é’¥å­˜å‚¨
â”‚   â”‚       â””â”€â”€ message_store.rs   # æ¶ˆæ¯å­˜å‚¨
â”‚   â””â”€â”€ tests/                 # æ ¸å¿ƒæµ‹è¯•
â”‚       â”œâ”€â”€ crypto_tests.rs
â”‚       â””â”€â”€ protocol_tests.rs
â”œâ”€â”€ native/                    # åŸç”Ÿåº”ç”¨ (è±†ç”Ÿæ€)
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs           # åº”ç”¨å…¥å£
â”‚   â”‚   â”œâ”€â”€ ui/               # ç”¨æˆ·ç•Œé¢
â”‚   â”‚   â”‚   â”œâ”€â”€ main_window.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ chat_view.rs
â”‚   â”‚   â”‚   â””â”€â”€ settings.rs
â”‚   â”‚   â”œâ”€â”€ integration/      # è±†ç”Ÿæ€é›†æˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ capability.rs # èƒ½åŠ›æ¨¡å‹
â”‚   â”‚   â”‚   â”œâ”€â”€ secure_storage.rs # å®‰å…¨å­˜å‚¨
â”‚   â”‚   â”‚   â””â”€â”€ hardware_key.rs    # ç¡¬ä»¶å¯†é’¥
â”‚   â”‚   â””â”€â”€ logic/           # ä¸šåŠ¡é€»è¾‘
â”‚   â”‚       â”œâ”€â”€ contact_manager.rs
â”‚   â”‚       â”œâ”€â”€ message_handler.rs
â”‚   â”‚       â””â”€â”€ call_manager.rs
â”‚   â””â”€â”€ resources/           # èµ„æºæ–‡ä»¶
â”‚       â””â”€â”€ ui/              # UIå®šä¹‰æ–‡ä»¶
â”œâ”€â”€ web/                     # Webåº”ç”¨ (çº¯å‰ç«¯)
â”‚   â”œâ”€â”€ index.html           # ä¸»é¡µé¢
â”‚   â”œâ”€â”€ manifest.json        # Webåº”ç”¨æ¸…å•
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.js          # åº”ç”¨å…¥å£
â”‚   â”‚   â”œâ”€â”€ app/             # åº”ç”¨ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ App.vue/App.svelte/App.etc
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatWindow.vue
â”‚   â”‚   â”‚   â””â”€â”€ ContactList.vue
â”‚   â”‚   â”œâ”€â”€ core/            # æ ¸å¿ƒé€»è¾‘ (WASM)
â”‚   â”‚   â”‚   â””â”€â”€ wasm-bridge.js # WASMæ¡¥æ¥
â”‚   â”‚   â”œâ”€â”€ crypto/          # Webç«¯åŠ å¯†
â”‚   â”‚   â”‚   â”œâ”€â”€ webcrypto-wrapper.js
â”‚   â”‚   â”‚   â””â”€â”€ key-management.js
â”‚   â”‚   â””â”€â”€ storage/         # æµè§ˆå™¨å­˜å‚¨
â”‚   â”‚       â”œâ”€â”€ indexeddb.js
â”‚   â”‚       â””â”€â”€ local-encrypted.js
â”‚   â”œâ”€â”€ public/             # é™æ€èµ„æº
â”‚   â””â”€â”€ build/              # æ„å»ºé…ç½®
â”œâ”€â”€ cli/                    # å‘½ä»¤è¡Œå·¥å…·
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ main.rs
â”‚       â””â”€â”€ commands/
â”œâ”€â”€ relay/                  # ä¸­ç»§æœåŠ¡å™¨ (å¯é€‰)
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ main.rs
â”‚       â”œâ”€â”€ server.rs       # æœåŠ¡å™¨å®ç°
â”‚       â””â”€â”€ message_relay.rs # æ¶ˆæ¯ä¸­ç»§
â””â”€â”€ tools/                  # å¼€å‘å·¥å…·
    â”œâ”€â”€ key-generator/      # å¯†é’¥ç”Ÿæˆå™¨
    â”œâ”€â”€ protocol-test/      # åè®®æµ‹è¯•å·¥å…·
    â””â”€â”€ benchmark/          # æ€§èƒ½æµ‹è¯•
```

ğŸš€ æ ¸å¿ƒä»£ç ç¤ºä¾‹

1. è‡ªä¸»ç«¯åˆ°ç«¯åŠ å¯†åè®®å®ç°

```rust
// æ–‡ä»¶ï¼šcore/src/crypto/double_ratchet.rs
// åŒæ£˜è½®ç®—æ³•å®Œå…¨è‡ªä¸»å®ç°

pub struct DoubleRatchet {
    root_key: [u8; 32],
    chain_keys_send: ChainKey,
    chain_keys_recv: ChainKey,
    ratchet_key_pair: KeyPair,
    remote_ratchet_key: Option<PublicKey>,
    message_keys: HashMap<u32, [u8; 32]>,
    skipped_message_keys: HashMap<u32, [u8; 32]>,
}

impl DoubleRatchet {
    pub fn new() -> Self {
        let root_key = Self::generate_random_32();
        let dh_key_pair = KeyPair::generate();
        
        DoubleRatchet {
            root_key,
            chain_keys_send: ChainKey::new(),
            chain_keys_recv: ChainKey::new(),
            ratchet_key_pair: dh_key_pair,
            remote_ratchet_key: None,
            message_keys: HashMap::new(),
            skipped_message_keys: HashMap::new(),
        }
    }
    
    pub fn initialize_as_alice(
        &mut self, 
        bob_identity_key: &PublicKey,
        bob_signed_prekey: &PublicKey,
        bob_one_time_prekey: Option<&PublicKey>
    ) -> Result<InitialMessage, CryptoError> {
        // 1. æ‰§è¡ŒX3DHå¯†é’¥äº¤æ¢
        let shared_secret = self.perform_x3dh(
            bob_identity_key,
            bob_signed_prekey,
            bob_one_time_prekey
        )?;
        
        // 2. æ´¾ç”Ÿæ ¹å¯†é’¥å’Œé“¾å¯†é’¥
        let (root_key, chain_key) = self.kdf_rk(
            &[0u8; 32], // åˆå§‹æ ¹å¯†é’¥ä¸º0
            &shared_secret
        );
        self.root_key = root_key;
        self.chain_keys_send = ChainKey::from_key(chain_key);
        
        // 3. æ‰§è¡ŒDHæ£˜è½®
        self.perform_dh_ratchet()?;
        
        // 4. æ„å»ºåˆå§‹æ¶ˆæ¯
        let initial_message = InitialMessage {
            identity_key: self.ratchet_key_pair.public_key(),
            ephemeral_key: self.generate_ephemeral_key(),
            one_time_prekey_id: bob_one_time_prekey.map(|_| 1),
        };
        
        Ok(initial_message)
    }
    
    pub fn encrypt_message(&mut self, plaintext: &[u8], ad: &[u8]) -> Result<EncryptedMessage, CryptoError> {
        // 1. æ´¾ç”Ÿæ¶ˆæ¯å¯†é’¥
        let (message_key, next_chain_key) = self.chain_keys_send.kdf_ck();
        self.chain_keys_send = next_chain_key;
        
        // 2. ä½¿ç”¨ChaCha20-Poly1305åŠ å¯†
        let nonce = Self::generate_nonce();
        let ciphertext = self.encrypt_chacha20_poly1305(
            plaintext,
            &message_key,
            &nonce,
            ad
        )?;
        
        // 3. æ„å»ºæ¶ˆæ¯å¤´
        let header = MessageHeader {
            ratchet_key: self.ratchet_key_pair.public_key(),
            message_number: self.chain_keys_send.message_number(),
            previous_message_number: self.chain_keys_send.previous_message_number(),
        };
        
        // 4. å­˜å‚¨æ¶ˆæ¯å¯†é’¥ï¼ˆç”¨äºå¯èƒ½çš„å»¶è¿Ÿæ¶ˆæ¯ï¼‰
        let message_number = header.message_number;
        self.message_keys.insert(message_number, message_key);
        
        Ok(EncryptedMessage {
            header,
            ciphertext,
            nonce,
        })
    }
    
    pub fn decrypt_message(&mut self, message: &EncryptedMessage, ad: &[u8]) -> Result<Vec<u8>, CryptoError> {
        let header = &message.header;
        
        // 1. æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°æ£˜è½®
        if header.ratchet_key != self.remote_ratchet_key.unwrap_or_default() {
            self.handle_new_ratchet_key(header.ratchet_key)?;
        }
        
        // 2. æŸ¥æ‰¾æ¶ˆæ¯å¯†é’¥
        let message_key = if let Some(key) = self.message_keys.get(&header.message_number) {
            *key
        } else if let Some(key) = self.skipped_message_keys.remove(&header.message_number) {
            key
        } else {
            // éœ€è¦æ´¾ç”Ÿç¼ºå¤±çš„æ¶ˆæ¯å¯†é’¥
            self.skip_message_keys(header.message_number)?;
            *self.message_keys.get(&header.message_number)
                .ok_or(CryptoError::MissingMessageKey)?
        };
        
        // 3. è§£å¯†æ¶ˆæ¯
        let plaintext = self.decrypt_chacha20_poly1305(
            &message.ciphertext,
            &message_key,
            &message.nonce,
            ad
        )?;
        
        // 4. æ¸…ç†å·²ä½¿ç”¨çš„æ¶ˆæ¯å¯†é’¥
        self.message_keys.remove(&header.message_number);
        
        Ok(plaintext)
    }
    
    // å‰å‘ä¿å¯†ï¼šå®šæœŸæ›´æ–°æ£˜è½®
    pub fn perform_ratchet_update(&mut self) -> Result<(), CryptoError> {
        let new_key_pair = KeyPair::generate();
        
        // è®¡ç®—æ–°çš„DHå…±äº«å¯†é’¥
        let dh_output = self.calculate_dh(
            &self.ratchet_key_pair,
            &self.remote_ratchet_key.ok_or(CryptoError::NoRemoteKey)?
        )?;
        
        // æ›´æ–°æ ¹å¯†é’¥å’Œé“¾å¯†é’¥
        let (new_root_key, new_chain_key) = self.kdf_rk(&self.root_key, &dh_output);
        self.root_key = new_root_key;
        self.chain_keys_recv = ChainKey::from_key(new_chain_key);
        
        // æ›´æ–°å¯†é’¥å¯¹
        self.ratchet_key_pair = new_key_pair;
        
        Ok(())
    }
}

// X3DHå¯†é’¥äº¤æ¢å®ç°
impl DoubleRatchet {
    fn perform_x3dh(
        &self,
        identity_key: &PublicKey,
        signed_prekey: &PublicKey,
        one_time_prekey: Option<&PublicKey>
    ) -> Result<[u8; 32], CryptoError> {
        let mut dh1 = self.calculate_dh(&self.ratchet_key_pair, identity_key)?;
        let dh2 = self.calculate_dh(&self.generate_ephemeral_key_pair(), signed_prekey)?;
        let dh3 = self.calculate_dh(&self.ratchet_key_pair, signed_prekey)?;
        
        let mut shared_secret = [0u8; 32];
        
        // ç»„åˆDHè¾“å‡º
        self.kdf1(&dh1, &mut shared_secret);
        self.kdf1(&dh2, &mut shared_secret);
        self.kdf1(&dh3, &mut shared_secret);
        
        if let Some(otpk) = one_time_prekey {
            let dh4 = self.calculate_dh(&self.generate_ephemeral_key_pair(), otpk)?;
            self.kdf1(&dh4, &mut shared_secret);
        }
        
        Ok(shared_secret)
    }
}
```

2. è±†èŠå¤©åè®® (DCP) æ¶ˆæ¯æ ¼å¼

```rust
// æ–‡ä»¶ï¼šcore/src/protocol/messages.rs
// è‡ªä¸»æ¶ˆæ¯åè®®è®¾è®¡

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MessageType {
    Text(TextMessage),
    Image(ImageMessage),
    File(FileMessage),
    Voice(VoiceMessage),
    Video(VideoMessage),
    Call(CallMessage),
    Group(GroupMessage),
    System(SystemMessage),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Envelope {
    pub version: u8,           // åè®®ç‰ˆæœ¬
    pub id: MessageId,         // æ¶ˆæ¯ID (UUID v7)
    pub timestamp: u64,        // çº³ç§’çº§æ—¶é—´æˆ³
    pub sender: Identity,      // å‘é€è€…èº«ä»½
    pub recipient: Recipient,  // æ¥æ”¶è€…ï¼ˆå•äººæˆ–ç¾¤ç»„ï¼‰
    pub message_type: MessageType,
    pub metadata: Metadata,    // å…ƒæ•°æ®ï¼ˆåŠ å¯†ï¼‰
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextMessage {
    pub content: EncryptedString, // åŠ å¯†æ–‡æœ¬
    pub mentions: Vec<Mention>,   // @æåŠ
    pub reply_to: Option<MessageId>, // å›å¤æ¶ˆæ¯ID
    pub formatting: Option<Formatting>, // å¯Œæ–‡æœ¬æ ¼å¼
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImageMessage {
    pub thumbnail: EncryptedData,  // ç¼©ç•¥å›¾ï¼ˆåŠ å¯†ï¼‰
    pub full_image: ImageData,     // å®Œæ•´å›¾åƒæ•°æ®æˆ–å¼•ç”¨
    pub dimensions: (u32, u32),    // å®½é«˜
    pub format: ImageFormat,       // æ ¼å¼ï¼šJPEG/PNG/WEBP
    pub caption: Option<EncryptedString>, // å¯é€‰æ ‡é¢˜
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileMessage {
    pub filename: EncryptedString,
    pub file_size: u64,
    pub mime_type: String,
    pub chunks: Vec<FileChunk>,    // åˆ†ç‰‡ä¼ è¾“
    pub hash: [u8; 32],           // SHA-256æ–‡ä»¶å“ˆå¸Œ
}

// åŠ å¯†æ¶ˆæ¯åŒ…è£…
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncryptedMessage {
    pub header: MessageHeader,     // æ¶ˆæ¯å¤´ï¼ˆæœªåŠ å¯†ï¼‰
    pub ciphertext: Vec<u8>,       // åŠ å¯†æ¶ˆæ¯ä½“
    pub auth_tag: [u8; 16],        // è®¤è¯æ ‡ç­¾
    pub nonce: [u8; 12],          // åŠ å¯†éšæœºæ•°
}

impl EncryptedMessage {
    pub fn encrypt(
        message: &Envelope,
        session: &mut DoubleRatchet,
        associated_data: &[u8]
    ) -> Result<Self, ProtocolError> {
        // åºåˆ—åŒ–æ¶ˆæ¯
        let plaintext = message.serialize()?;
        
        // ä½¿ç”¨åŒæ£˜è½®åŠ å¯†
        let encrypted = session.encrypt_message(&plaintext, associated_data)?;
        
        Ok(EncryptedMessage {
            header: encrypted.header,
            ciphertext: encrypted.ciphertext,
            auth_tag: encrypted.auth_tag,
            nonce: encrypted.nonce,
        })
    }
    
    pub fn decrypt(
        &self,
        session: &mut DoubleRatchet,
        associated_data: &[u8]
    ) -> Result<Envelope, ProtocolError> {
        // ä½¿ç”¨åŒæ£˜è½®è§£å¯†
        let plaintext = session.decrypt_message(self, associated_data)?;
        
        // ååºåˆ—åŒ–æ¶ˆæ¯
        Envelope::deserialize(&plaintext)
    }
}
```

3. Webç«¯çº¯å‰ç«¯å®ç°

```javascript
// æ–‡ä»¶ï¼šweb/src/core/wasm-bridge.js
// WebAssemblyæ¡¥æ¥ï¼Œä½¿ç”¨æ ¸å¿ƒRuståº“

class DouChatWeb {
    constructor() {
        this.wasmModule = null;
        this.crypto = new WebCryptoWrapper();
        this.storage = new EncryptedStorage();
        this.sessions = new Map();
    }
    
    async initialize() {
        // 1. åŠ è½½WASMæ ¸å¿ƒæ¨¡å—
        this.wasmModule = await import('../../core/pkg/dou_chat_core.js');
        await this.wasmModule.default();
        
        // 2. åˆå§‹åŒ–æœ¬åœ°èº«ä»½
        await this.initializeIdentity();
        
        // 3. åŠ è½½ç°æœ‰ä¼šè¯
        await this.loadSessions();
        
        // 4. å»ºç«‹ç½‘ç»œè¿æ¥
        await this.setupNetwork();
    }
    
    async initializeIdentity() {
        // æ£€æŸ¥æ˜¯å¦æœ‰ç°æœ‰èº«ä»½
        let identity = await this.storage.get('identity');
        
        if (!identity) {
            // ç”Ÿæˆæ–°èº«ä»½
            identity = await this.generateNewIdentity();
            await this.storage.set('identity', identity, true); // åŠ å¯†å­˜å‚¨
        }
        
        this.identity = identity;
    }
    
    async generateNewIdentity() {
        // 1. ç”Ÿæˆå¯†é’¥å¯¹
        const keyPair = await this.crypto.generateKeyPair({
            name: 'ECDH',
            namedCurve: 'P-256'
        });
        
        // 2. ç”Ÿæˆç­¾åå¯†é’¥å¯¹
        const signingKeyPair = await this.crypto.generateKeyPair({
            name: 'ECDSA',
            namedCurve: 'P-256',
            hash: 'SHA-256'
        });
        
        // 3. ç”Ÿæˆèº«ä»½IDï¼ˆåŸºäºå…¬é’¥ï¼‰
        const identityId = await this.crypto.hash(
            await this.crypto.exportKey('spki', keyPair.publicKey)
        );
        
        // 4. ç”ŸæˆåŠ©è®°è¯ï¼ˆç”¨äºæ¢å¤ï¼‰
        const mnemonic = this.generateMnemonic();
        
        return {
            id: identityId,
            keyPair: keyPair,
            signingKeyPair: signingKeyPair,
            mnemonic: mnemonic,
            created: Date.now()
        };
    }
    
    async startSession(remoteIdentity) {
        // ä½¿ç”¨WASMæ‰§è¡ŒX3DHå¯†é’¥äº¤æ¢
        const session = this.wasmModule.create_session(
            this.identity.keyPair.privateKey,
            remoteIdentity.publicKey,
            remoteIdentity.signedPrekey
        );
        
        // æ„å»ºåˆå§‹æ¶ˆæ¯
        const initialMessage = this.wasmModule.build_initial_message(session);
        
        // å­˜å‚¨ä¼šè¯çŠ¶æ€
        this.sessions.set(remoteIdentity.id, session);
        await this.saveSession(session);
        
        return initialMessage;
    }
    
    async sendMessage(recipientId, message) {
        const session = this.sessions.get(recipientId);
        if (!session) {
            throw new Error('No session with recipient');
        }
        
        // åŠ å¯†æ¶ˆæ¯
        const encrypted = this.wasmModule.encrypt_message(
            session,
            JSON.stringify(message)
        );
        
        // æ„å»ºåè®®æ¶ˆæ¯
        const envelope = {
            version: 1,
            id: this.generateMessageId(),
            timestamp: Date.now(),
            sender: this.identity.id,
            recipient: recipientId,
            message: encrypted
        };
        
        // å‘é€ï¼ˆé€šè¿‡WebRTCæˆ–WebSocketï¼‰
        await this.network.send(recipientId, envelope);
        
        // æœ¬åœ°å­˜å‚¨ï¼ˆåŠ å¯†ï¼‰
        await this.storage.storeMessage(envelope);
    }
    
    async receiveMessage(envelope) {
        const session = this.sessions.get(envelope.sender);
        if (!session) {
            // å¤„ç†åˆå§‹æ¶ˆæ¯ï¼Œå»ºç«‹æ–°ä¼šè¯
            await this.handleInitialMessage(envelope);
            return;
        }
        
        // è§£å¯†æ¶ˆæ¯
        const decrypted = this.wasmModule.decrypt_message(
            session,
            envelope.message
        );
        
        // éªŒè¯æ¶ˆæ¯å®Œæ•´æ€§
        if (!this.verifyMessage(decrypted, envelope)) {
            throw new Error('Message verification failed');
        }
        
        // æ›´æ–°ä¼šè¯çŠ¶æ€
        this.wasmModule.update_session(session, envelope.message.header);
        await this.saveSession(session);
        
        // è§¦å‘æ¶ˆæ¯æ¥æ”¶äº‹ä»¶
        this.emit('message', {
            id: envelope.id,
            sender: envelope.sender,
            timestamp: envelope.timestamp,
            content: decrypted
        });
    }
    
    // WebRTCç‚¹å¯¹ç‚¹è¿æ¥
    async setupPeerConnection(remoteId) {
        const config = {
            iceServers: [
                // è‡ªä¸»STUN/TURNæœåŠ¡å™¨æˆ–ä½¿ç”¨è±†ç”Ÿæ€ä¸­ç»§
                { urls: 'stun:relay.douchat.io' },
                { urls: 'turn:relay.douchat.io', credential: 'demo', username: 'demo' }
            ],
            iceCandidatePoolSize: 10,
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require'
        };
        
        const pc = new RTCPeerConnection(config);
        
        // æ•°æ®é€šé“ï¼ˆç”¨äºæ¶ˆæ¯ä¼ è¾“ï¼‰
        const dc = pc.createDataChannel('douchat', {
            ordered: true,          // ä¿æŒæ¶ˆæ¯é¡ºåº
            maxRetransmits: 5,      // æœ€å¤§é‡ä¼ æ¬¡æ•°
            protocol: 'dcp'         // è±†èŠå¤©åè®®
        });
        
        dc.onopen = () => {
            console.log('Data channel opened');
            this.connections.set(remoteId, { pc, dc });
        };
        
        dc.onmessage = (event) => {
            this.handleDataChannelMessage(remoteId, event.data);
        };
        
        // ç”ŸæˆSDP offer
        const offer = await pc.createOffer({
            offerToReceiveAudio: false,
            offerToReceiveVideo: false
        });
        
        await pc.setLocalDescription(offer);
        
        return offer;
    }
}
```

4. è±†ç”Ÿæ€åŸç”Ÿåº”ç”¨é›†æˆ

```rust
// æ–‡ä»¶ï¼šnative/src/integration/secure_storage.rs
// è±†ç”Ÿæ€å®‰å…¨å­˜å‚¨å®ç°

use doukernel::capabilities::{Capability, StorageAccess};
use doukernel::crypto::SecureEnclave;

pub struct SecureStorage {
    capability: Capability,
    enclave: SecureEnclave,
}

impl SecureStorage {
    pub fn new() -> Result<Self, StorageError> {
        // è¯·æ±‚å®‰å…¨å­˜å‚¨èƒ½åŠ›
        let capability = Capability::request("secure-storage")
            .with_constraints(vec![
                Constraint::Isolated,      // éš”ç¦»å­˜å‚¨
                Constraint::Encrypted,     // è‡ªåŠ¨åŠ å¯†
                Constraint::TamperProof,   // é˜²ç¯¡æ”¹
            ])
            .acquire()?;
        
        // åˆå§‹åŒ–å®‰å…¨é£åœ°ï¼ˆç¡¬ä»¶æ”¯æŒï¼‰
        let enclave = SecureEnclave::initialize()?;
        
        Ok(SecureStorage { capability, enclave })
    }
    
    pub async fn store_key(&self, key_id: &str, key_data: &[u8]) -> Result<(), StorageError> {
        // 1. åœ¨å®‰å…¨é£åœ°å†…åŠ å¯†å¯†é’¥
        let encrypted_key = self.enclave.encrypt_key(key_data)?;
        
        // 2. é€šè¿‡èƒ½åŠ›ä¿æŠ¤çš„æ¥å£å­˜å‚¨
        self.capability.write(
            &format!("keys/{}", key_id),
            &encrypted_key,
            WriteOptions {
                atomic: true,
                backup: true,  // è‡ªåŠ¨å¤‡ä»½
                sync: true,    // åŒæ­¥å†™å…¥
            }
        ).await?;
        
        Ok(())
    }
    
    pub async fn load_key(&self, key_id: &str) -> Result<Vec<u8>, StorageError> {
        // 1. é€šè¿‡èƒ½åŠ›ä¿æŠ¤çš„æ¥å£è¯»å–
        let encrypted_key = self.capability.read(
            &format!("keys/{}", key_id),
            ReadOptions::default()
        ).await?;
        
        // 2. åœ¨å®‰å…¨é£åœ°å†…è§£å¯†
        let key_data = self.enclave.decrypt_key(&encrypted_key)?;
        
        Ok(key_data)
    }
    
    pub async fn store_message(&self, session_id: &str, message: &EncryptedMessage) -> Result<(), StorageError> {
        // ä½¿ç”¨ä¼šè¯ç‰¹å®šå¯†é’¥åŠ å¯†æ¶ˆæ¯
        let session_key = self.derive_session_key(session_id)?;
        
        let encrypted_data = self.enclave.encrypt_with_key(
            &session_key,
            &message.serialize()?,
            &format!("msg/{}", message.id)
        )?;
        
        // å­˜å‚¨åˆ°åŠ å¯†æ•°æ®åº“
        self.capability.write(
            &format!("messages/{}/{}", session_id, message.id),
            &encrypted_data,
            WriteOptions {
                atomic: true,
                backup: false,  // æ¶ˆæ¯ä¸å¤‡ä»½ï¼ˆå®‰å…¨è€ƒè™‘ï¼‰
                sync: false,    // å¼‚æ­¥å†™å…¥
            }
        ).await?;
        
        Ok(())
    }
}
```

5. åé‡å­åŠ å¯†æ··åˆæ–¹æ¡ˆ

```rust
// æ–‡ä»¶ï¼šcore/src/crypto/pqc.rs
// åé‡å­åŠ å¯†æ”¯æŒ

pub struct HybridEncryption {
    classical: ECDH,      // ä¼ ç»Ÿæ¤­åœ†æ›²çº¿åŠ å¯†
    post_quantum: Kyber,  // åé‡å­ç®—æ³•ï¼ˆKyber-1024ï¼‰
}

impl HybridEncryption {
    pub fn new() -> Self {
        HybridEncryption {
            classical: ECDH::new(P256),
            post_quantum: Kyber::kyber1024(),
        }
    }
    
    pub fn encrypt(&self, recipient_public_key: &HybridPublicKey, plaintext: &[u8]) -> Result<HybridCiphertext, CryptoError> {
        // 1. ç”Ÿæˆä¸´æ—¶å¯†é’¥å¯¹ï¼ˆä¼ ç»Ÿ + åé‡å­ï¼‰
        let ephemeral_classical = self.classical.generate_keypair();
        let ephemeral_pq = self.post_quantum.generate_keypair();
        
        // 2. è®¡ç®—ä¸¤ä¸ªå…±äº«å¯†é’¥
        let shared_classical = self.classical.dh(
            &ephemeral_classical.private_key,
            &recipient_public_key.classical
        )?;
        
        let (shared_pq, encapsulation) = self.post_quantum.encapsulate(
            &recipient_public_key.post_quantum
        )?;
        
        // 3. ç»„åˆå…±äº«å¯†é’¥
        let combined_key = self.kdf_combine(&shared_classical, &shared_pq);
        
        // 4. ä½¿ç”¨ç»„åˆå¯†é’¥åŠ å¯†
        let ciphertext = self.encrypt_aes_gcm(&combined_key, plaintext)?;
        
        Ok(HybridCiphertext {
            ephemeral_classical_public: ephemeral_classical.public_key,
            ephemeral_pq_public: ephemeral_pq.public_key,
            encapsulation,
            ciphertext,
        })
    }
    
    pub fn decrypt(&self, private_key: &HybridPrivateKey, ciphertext: &HybridCiphertext) -> Result<Vec<u8>, CryptoError> {
        // 1. è®¡ç®—ä¸¤ä¸ªå…±äº«å¯†é’¥
        let shared_classical = self.classical.dh(
            &private_key.classical,
            &ciphertext.ephemeral_classical_public
        )?;
        
        let shared_pq = self.post_quantum.decapsulate(
            &private_key.post_quantum,
            &ciphertext.encapsulation
        )?;
        
        // 2. ç»„åˆå…±äº«å¯†é’¥
        let combined_key = self.kdf_combine(&shared_classical, &shared_pq);
        
        // 3. è§£å¯†æ¶ˆæ¯
        self.decrypt_aes_gcm(&combined_key, &ciphertext.ciphertext)
    }
}

// ç”¨äºåŒæ£˜è½®çš„åé‡å­å¢å¼º
pub struct PostQuantumDoubleRatchet {
    base_ratchet: DoubleRatchet,
    pq_ratchet: PQRatchet,
}

impl PostQuantumDoubleRatchet {
    pub fn encrypt_message(&mut self, plaintext: &[u8]) -> Result<PostQuantumMessage, CryptoError> {
        // 1. ä½¿ç”¨ä¼ ç»ŸåŒæ£˜è½®åŠ å¯†
        let classical_message = self.base_ratchet.encrypt_message(plaintext)?;
        
        // 2. ä½¿ç”¨åé‡å­å¯†é’¥åŠ å¯†ä¼ ç»Ÿæ¶ˆæ¯å¯†é’¥
        let encrypted_key = self.pq_ratchet.encrypt_key(&classical_message.message_key)?;
        
        Ok(PostQuantumMessage {
            classical_header: classical_message.header,
            encrypted_message_key: encrypted_key,
            ciphertext: classical_message.ciphertext,
            pq_info: self.pq_ratchet.current_state(),
        })
    }
}
```

ğŸ“ˆ å¼€å‘è·¯çº¿å›¾

é˜¶æ®µ0ï¼šæ ¸å¿ƒåè®®åº“ (6-12ä¸ªæœˆ)

Â· åŒæ£˜è½®ç®—æ³•å®Œå…¨è‡ªä¸»å®ç°
Â· X3DHå¯†é’¥äº¤æ¢åè®®
Â· æ¶ˆæ¯åè®®æ ¼å¼å®šä¹‰
Â· åŸºç¡€åŠ å¯†ç®—æ³•å®ç°

é˜¶æ®µ1ï¼šWebåº”ç”¨å¼€å‘ (6-12ä¸ªæœˆ)

Â· çº¯å‰ç«¯Webç•Œé¢
Â· WebAssemblyæ ¸å¿ƒé›†æˆ
Â· WebRTCç‚¹å¯¹ç‚¹è¿æ¥
Â· æµè§ˆå™¨ç«¯åŠ å¯†å­˜å‚¨

é˜¶æ®µ2ï¼šåŸç”Ÿåº”ç”¨å¼€å‘ (8-12ä¸ªæœˆ)

Â· è±†ç”Ÿæ€åŸç”ŸUIæ¡†æ¶é›†æˆ
Â· å®‰å…¨å­˜å‚¨å’Œå¯†é’¥ç®¡ç†
Â· ç¡¬ä»¶åŠ å¯†æ”¯æŒ
Â· ç³»ç»Ÿé€šçŸ¥é›†æˆ

é˜¶æ®µ3ï¼šé«˜çº§åŠŸèƒ½ (12-18ä¸ªæœˆ)

Â· ç¾¤ç»„ç«¯åˆ°ç«¯åŠ å¯†
Â· è¯­éŸ³è§†é¢‘é€šè¯
Â· æ–‡ä»¶å®‰å…¨ä¼ è¾“
Â· åé‡å­åŠ å¯†æ”¯æŒ

é˜¶æ®µ4ï¼šç”Ÿæ€ç³»ç»Ÿ (18-24ä¸ªæœˆ)

Â· å»ä¸­å¿ƒåŒ–èº«ä»½ç³»ç»Ÿ
Â· å¼€æ”¾åè®®æ ‡å‡†
Â· ç¬¬ä¸‰æ–¹å®¢æˆ·ç«¯æ”¯æŒ
Â· å®¡è®¡å’Œå®‰å…¨è®¤è¯

ğŸ”¨ æ„å»ºæŒ‡å—

æ ¸å¿ƒåº“æ„å»º (Rust)

```bash
# 1. å®‰è£…Rustå·¥å…·é“¾
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 2. è·å–æºä»£ç 
git clone https://github.com/DouEcoSys/DouChat.git
cd DouChat/core

# 3. æ„å»ºæ ¸å¿ƒåº“
cargo build --release --features "wasm"

# 4. æ„å»ºWebAssembly
cargo build --target wasm32-unknown-unknown --release
wasm-bindgen target/wasm32-unknown-unknown/release/dou_chat_core.wasm --out-dir ../../web/src/core/pkg
```

Webåº”ç”¨æ„å»º

```bash
cd ../web
npm install
npm run build
# ç”Ÿæˆçº¯é™æ€æ–‡ä»¶ï¼Œå¯éƒ¨ç½²åˆ°ä»»ä½•WebæœåŠ¡å™¨
```

åŸç”Ÿåº”ç”¨æ„å»º (è±†ç”Ÿæ€)

```bash
cd ../native
cargo build --release --target your-target
# éœ€è¦è±†ç”Ÿæ€SDKå’Œå·¥å…·é“¾
```

ğŸ‘¥ å®‰å…¨å®¡è®¡è¦æ±‚

å¿…é¡»é€šè¿‡çš„å®‰å…¨è®¤è¯

1. å¯†ç å­¦å®¡è®¡ï¼šç”±ç‹¬ç«‹å¯†ç å­¦ä¸“å®¶å®¡è®¡
2. åè®®å®‰å…¨ï¼šå½¢å¼åŒ–éªŒè¯åè®®å®‰å…¨æ€§
3. å®ç°å®¡è®¡ï¼šä»£ç çº§å®‰å…¨å®¡è®¡
4. æ¸—é€æµ‹è¯•ï¼šé»‘ç›’å’Œç™½ç›’æµ‹è¯•

æ¼æ´æŠ«éœ²è®¡åˆ’

Â· ä¸¥æ ¼éµå¾ªè´Ÿè´£ä»»æŠ«éœ²åŸåˆ™
Â· è®¾ç«‹å®‰å…¨æ¼æ´å¥–é‡‘
Â· 90å¤©å†…ä¿®å¤ä¸¥é‡æ¼æ´
Â· å®Œå…¨é€æ˜çš„å®‰å…¨å…¬å‘Š

ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨ GNU Affero General Public License v3.0 (AGPLv3)ï¼Œç¡®ä¿æ‰€æœ‰ä¿®æ”¹å’Œè¡ç”Ÿä½œå“ä¿æŒå¼€æºï¼ŒåŒ…æ‹¬ç½‘ç»œæœåŠ¡ç‰ˆæœ¬ã€‚

---

è±†åŠ å¯†èŠå¤© - ä»åè®®åˆ°å®ç°çš„å®Œå…¨è‡ªä¸»ã€ç«¯åˆ°ç«¯åŠ å¯†çš„é€šä¿¡è§£å†³æ–¹æ¡ˆ
